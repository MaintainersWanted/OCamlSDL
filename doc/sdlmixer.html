<HTML>
  <HEAD>

  <META http-equiv="Content-Type" content="text/html">
  <META name="GENERATOR" content="cdk_doc">
  <TITLE> Module   Sdlmixer  </TITLE>
  </HEAD>
  <BODY TEXT=black BGCOLOR=white>
  <TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
  <TR><TD BGCOLOR="#60ff60"><DIV ALIGN=center><TABLE>
  <TR><TD><B><FONT SIZE=5> Module <TT> Sdlmixer <TT> </FONT></B></TD>
  </TR></TABLE></DIV></TD>
  </TR></TABLE>
<P>
<BLOCKQUOTE>
Define a new exception for loader errors and register 
it to be callable from C code. 
</BLOCKQUOTE>

<P>
<BLOCKQUOTE>
Exception 
</BLOCKQUOTE>

<PRE>
exception SDLmixer_exception of string


</PRE>

<P>
<BLOCKQUOTE>
Types 
</BLOCKQUOTE>

<PRE>
type format =
 | AUDIO_FORMAT_DEFAULT
 | AUDIO_FORMAT_U8
 | AUDIO_FORMAT_S8
 | AUDIO_FORMAT_U16
 | AUDIO_FORMAT_S16


</PRE>

<PRE>
type fade_status =
 | NO_FADING
 | FADING_OUT
 | FADING_IN


</PRE>

<PRE>
type channels = MONO | STEREO


</PRE>

<PRE>
type chunk

</PRE>

<PRE>
type music

</PRE>

<PRE>
type channel = int

</PRE>

<PRE>
type group = int

</PRE>

<PRE>
type specs =
  { frequency : int;
    format : format;
    channels : int }


</PRE>

<PRE>
val open_audio : int -> format -> channels -> unit

</PRE>

<P>
<BLOCKQUOTE>

<CODE>open_audio frequency format channels</CODE> open the mixer with a certain 
audio format.
frequency could be 8000 11025 22050 44100

</BLOCKQUOTE>

<P>
<BLOCKQUOTE>
chuncksize is 4096 
</BLOCKQUOTE>

<PRE>
val close_audio : unit -> unit

</PRE>

<P>
<BLOCKQUOTE>
Close the mixer, halting all playing audio 
</BLOCKQUOTE>

<PRE>
val query_specs : unit -> specs option

</PRE>

<P>
<BLOCKQUOTE>
This function returns what the actual audio device parameters are. 
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Loading and freeing sounds </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val loadWAV : string -> chunk 

</PRE>

<P>
<BLOCKQUOTE>
Load a wave file 
</BLOCKQUOTE>

<PRE>
val load_string : string -> chunk

</PRE>

<P>
<BLOCKQUOTE>
Load a wave file of the mixer format from a memory buffer 
</BLOCKQUOTE>

<PRE>
val load_music : string -> music

</PRE>

<P>
<BLOCKQUOTE>
Load a music file (.mod .s3m .it .xm) 
</BLOCKQUOTE>

<PRE>
val free_chunk : chunk -> unit

</PRE>

<P>
<BLOCKQUOTE>
Free an audio chunk previously loaded 
</BLOCKQUOTE>

<PRE>
val free_music : music -> unit

</PRE>

<P>
<BLOCKQUOTE>
Free music previously loaded 
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Hooks </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val set_postmix : (string -> unit) -> unit

</PRE>

<P>
<BLOCKQUOTE>

Set a function <CODE>string -&gt; unit</CODE> that is called after all mixing 
is performed. This can be used to provide real-time visual 
display of the audio stream or add a custom mixer filter 
for the stream data.

</BLOCKQUOTE>

<PRE>
val set_music : (string -> unit) -> unit

</PRE>

<P>
<BLOCKQUOTE>
Add your own music player or additional mixer function. 
</BLOCKQUOTE>

<PRE>
val set_music_finished : (unit -> unit) -> unit

</PRE>

<P>
<BLOCKQUOTE>
Add your own callback <CODE>unit -&gt; unit</CODE> when the music has finished 
playing. 
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Groups and channels </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val allocate_channels : int -> int

</PRE>

<P>
<BLOCKQUOTE>

Dynamically change the number of channels managed by the mixer.
If decreasing the number of channels, the upper channels are
stopped.
This function returns the new number of allocated channels.

</BLOCKQUOTE>

<PRE>
val reserve_channels : int -> int

</PRE>

<P>
<BLOCKQUOTE>

Reserve the first channels (0 -&gt; n-1) for the application, i.e. don't allocate
them dynamically to the next sample if requested with a -1 value below.
Returns the number of reserved channels.

</BLOCKQUOTE>

<PRE>
val group_channel : channel -> group option -> unit

</PRE>

<PRE>
val group_available : group -> channel

</PRE>

<P>
<BLOCKQUOTE>
Finds the first available <CODE>channel</CODE> in a <CODE>group</CODE> of channels 
</BLOCKQUOTE>

<PRE>
val group_count : group -> int

</PRE>

<P>
<BLOCKQUOTE>

Returns the number of channels in a group. This is also a subtle
way to get the total number of channels when <CODE>group</CODE> is -1 

</BLOCKQUOTE>

<PRE>
val group_oldest : group -> channel

</PRE>

<P>
<BLOCKQUOTE>
Finds the "oldest" sample playing in a <CODE>group</CODE> of channels 
</BLOCKQUOTE>

<PRE>
val group_newer : group -> channel

</PRE>

<P>
<BLOCKQUOTE>
Finds the "most recent" (i.e. last) sample playing in a <CODE>group</CODE> of channels 
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Playing </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val play_sound : chunk -> unit

</PRE>

<P>
<BLOCKQUOTE>
Play an audio chunk 
</BLOCKQUOTE>

<PRE>
val play_channel : channel option -> chunk -> int option -> float option -> channel

</PRE>

<P>
<BLOCKQUOTE>
<CODE>play_channel channel chunck loops ticks</CODE>
Play an audio chunk 
If the specified channel is -1, play on the first free channel.
If 'loops' is greater than zero, loop the sound that many times.
If 'loops' is -1, loop inifinitely (~65000 times).
Returns which channel was used to play the sound. 

</BLOCKQUOTE>

<PRE>
val play_music : music -> int option -> channel

</PRE>

<P>
<BLOCKQUOTE>
The same as above, but the sound is played at most 'ticks' milliseconds 
</BLOCKQUOTE>

<PRE>
val fadein_channel : channel option -> chunk -> int option -> float option -> float option -> channel

</PRE>

<P>
<BLOCKQUOTE>
<CODE>fadein_channel channel chunck loops ticks</CODE>
Fade in a channel over "ms" milliseconds, same semantics as the <CODE>play</CODE> functions 
</BLOCKQUOTE>

<PRE>
val fadein_music : music -> int option -> float option -> channel

</PRE>

<P>
<BLOCKQUOTE>
<CODE>fadein_music music chunck loops ticks</CODE>
Fade in music over "ms" milliseconds, same semantics as the <CODE>play</CODE> functions 
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Volume control </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val volume_channel : channel option -> float

</PRE>

<PRE>
val volume_chunk : chunk -> float

</PRE>

<PRE>
val volume_music : music -> float

</PRE>

<P>
<BLOCKQUOTE>
Returns the original volume of a specific channel, chunk or music 
</BLOCKQUOTE>

<PRE>
val setvolume_channel : channel option -> float -> unit

</PRE>

<PRE>
val setvolume_chunk : chunk -> float -> unit

</PRE>

<PRE>
val setvolume_music : music -> float -> unit

</PRE>

<P>
<BLOCKQUOTE>
Set the volume in the range of 0-128 of a specific channel, chunk 
or music.
If the specified channel is -1, set volume for all channels.
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Stopping playing </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val halt_channel : channel -> unit

</PRE>

<PRE>
val halt_group : group -> unit

</PRE>

<PRE>
val halt_music : unit -> unit


</PRE>

<PRE>
val expire_channel : channel -> float option -> unit

</PRE>

<P>
<BLOCKQUOTE>
<CODE>expire_channel channel ticks</CODE>
Change the expiration delay for a particular channel.
The sample will stop playing after the 'ticks' milliseconds have elapsed,
or remove the expiration if 'ticks' is -1

</BLOCKQUOTE>

<PRE>
val fadeout_channel : channel -> float -> unit

</PRE>

<P>
<BLOCKQUOTE>
<CODE>fadeout_channel channel ticks</CODE>
Halt a channel, fading it out progressively till it's silent
The ms parameter indicates the number of milliseconds the fading
will take.

</BLOCKQUOTE>

<PRE>
val fadeout_group : group -> float -> unit

</PRE>

<P>
<BLOCKQUOTE>
<CODE>fadeout_group group ticks</CODE>
Halt a group of channel, fading it out progressively till it's silent
The ms parameter indicates the number of milliseconds the fading
will take.

</BLOCKQUOTE>

<PRE>
val fadeout_music : float -> unit

</PRE>

<P>
<BLOCKQUOTE>
<CODE>fadeout_music ticks</CODE>
Halt the music, fading it out progressively till it's silent
The ms parameter indicates the number of milliseconds the fading
will take.

</BLOCKQUOTE>

<PRE>
val fading_music : unit -> fade_status

</PRE>

<P>
<BLOCKQUOTE>
Query the fading status of a music 
</BLOCKQUOTE>

<PRE>
val fading_channel : channel -> fade_status

</PRE>

<P>
<BLOCKQUOTE>
Query the fading status of a channel 
</BLOCKQUOTE>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%%">
<TR><TD BGCOLOR="#70ff70"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=2> Pausing / resuming </FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<PRE>
val pause_channel : channel -> unit

</PRE>

<PRE>
val resume_channel : channel -> unit

</PRE>

<PRE>
val paused_channel : channel -> bool

</PRE>

<PRE>
val pause_music : unit -> unit

</PRE>

<PRE>
val resume_music : unit -> unit

</PRE>

<PRE>
val rewind_music : unit -> unit

</PRE>

<PRE>
val paused_music : unit -> bool

</PRE>

<PRE>
val playing : channel option -> bool

</PRE>

<PRE>val playing_music : unit -> bool
</PRE>

</BODY>
</HTML>